#include <stdlib.h>
#include <stdio.h>
#include <string.h>
// OMFG INCLUDE GLEW FIRST NEVER NOT INCLUDE GLEW FIRST
// FIRST FIRST FIRST GLEW FIRST
#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include "gl-matrix/gl-matrix.h"

// Number of vertices in a cube of 12 triangles.
#define NUM_VERTICES 36
// Number of floats per vertex position.
#define NUM_PER_POSITION 3
// Number of shakes per vertex color.
#define NUM_PER_COLOR 3

//shader source code strings
const char VERT_SRC[] =
"#version 120"
"// The position data of the current vertex.\n"
"attribute vec4 posAttrib;\n"
"// The color data of the current vertex.\n"
"attribute vec4 colorAttrib;\n"
"// The transformation matrices.\n"
"uniform mat4 projection, modelview;\n"
"varying vec4 color;\n"
"void main(void)\n"
"{\n"
"    // Copy this vertex' color to our varying slot so\n"
"    // that we can use it interpolated in the fragment shader.\n"
"    color = colorAttrib;\n"
"    "
"    // Apply the vertex transformations detailed in the matrices.\n"
"    gl_Position = projection*modelview*posAttrib;\n"
"}";

const char FRAG_SRC[] =
"#version 120\n"
"// Oh hey look it's our friend \"Color.\" Let's hope he/she\n"
"// enjoyed the ride through the rasterizer.\n"
"varying vec4 color;\n"
"void main(void)\n"
"{\n"
"    // Eh, let's just copy this color straight on out.\n"
"    gl_FragColor = color;\n"
"}";

// Arrays to store vertex data.
float positions[] = {0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 
                1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 
                1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 
                1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 
                0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 
                0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 
                1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f};

float colors[] = {1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
                1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,
                0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
                0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
                1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,
                0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f};


// Handle to shader program.
GLuint shaderProgram;
// Handles to the position and color attributes.
GLuint posAttrib, colorAttrib;

// GLFW window handle.
GLFWwindow * window;

/**
	Compiles a shader object and returns its handle.
	
	Parameters:
	filename (const GLchar*): The filename of the shader source.
	type (GLenum): The type of shader as which to compile as.
		
	Returns:
	GLuint: The handle of the newly created shader, or 0.
*/
GLuint compileShader(const GLchar * source, GLenum type)
{
	// Make sure the specified shader type is valid.
	if(type != GL_VERTEX_SHADER && type != GL_FRAGMENT_SHADER)
		return 0;
	// Create the shader object on the GPU.
	GLuint shader = glCreateShader(type);
	// Send it the source code.
	glShaderSource(shader, 1, &source, 0);
	// Compile it.
	glCompileShader(shader);
	// Create a variable to store compilation status.
	GLint status;
	// Get that compilation status.
	glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
	
	// If the shader didn't compile, we have work to do.
	if(status == GL_FALSE) {
		// Alert the user.
		printf("could not compile shader of type %d\n", type);
		// Create a variable to store the length of the info log
		// generated by the error, and retrieve it.
		int infoLogLength;
		glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLogLength);
		// Create a string large enough to store the info log,
		// then likewise store it.
		char * infoLog = malloc(sizeof(char)*infoLogLength);
		glGetShaderInfoLog(shader, infoLogLength, &infoLogLength, infoLog);
		// Print the error to the screen.
		printf("Shader errors:\n%s\n", infoLog);
		// We don't leak shit in here.
		free(infoLog);
	}
	
	// This may or may not be necessary, but it is a fun illustration
	// of the third kind of if statement.
	return status == GL_FALSE ? 0 : shader;
}

/**
	Initializes a shader program, loading both vertex and fragment
	shader sources, compiling then linking them.
	
	Parameters:
	vertFilename (const char*): The filename of the vertex shader source.
	fragFilename (const char*): The filename of the fragment shader source.
	
	Returns:
	GLuint: The handle of the infant baby shader program.
*/
GLuint initShaderProgram(const char * vertFilename, const char * fragFilename)
{
	// Load and compile the two shader objects needed.
	GLuint vert = compileShader(vertFilename, GL_VERTEX_SHADER);
	GLuint frag = compileShader(fragFilename, GL_FRAGMENT_SHADER);
	// Look at how integers can be treated in C-language if statements.
	if(!vert || !frag)
		return 0;
	// Create the full shader program on the GPU.
	GLint program = glCreateProgram();
	// Attach both shader objects to this new program.
	glAttachShader(program, vert);
	glAttachShader(program, frag);
	// Link the program. Now, if this links, the shader executables
	// are duplicated into this program.
	glLinkProgram(program);
	
	// Get the link status of our program. 
	GLint linked;
	glGetProgramiv(program, GL_LINK_STATUS, &linked);
	
	// If it didn't link--well, poop.
	if(linked == GL_FALSE)
	{
		printf("Shader program failed to link.");
		return 0;
	}
	// Otherwise we are able to clear out our compilation mess.
	else
	{
		glDetachShader(program, vert);
		glDeleteShader(vert);
		glDetachShader(program, frag);
		glDeleteShader(frag);
	}
	
	// Finally we return the program.
	return program;
}

/**
	Initializes the lot of the geometry data, shader program, and
	GLFW.
	
	Parameters:
		None
	Returns:
		-1 if any initialization step fails, 0 otherwise.
*/
int init(void)
{
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    // Initialize GLFW.
	if(!glfwInit()) {
	    printf("init glfw failed");
    	return 1;
	}
	// Create our GLFW window.
    window = glfwCreateWindow(640, 480, "OpenGL Seminar A", NULL, NULL);
	
	// If that window creation operation failed, we forego our existing
	// work in initializing GLFW and return a generic error code.
    if (!window)
    {
        printf("creating window failed");
        glfwTerminate();
        return 1;
    }
	
	// Otherwise we tell GLFW that we want to operate on that window,
	glfwMakeContextCurrent(window);
	// And set up some basic OpenGL state.
	// The color that pixels are flushed to when clearing a color buffer.
	glewInit();

    glClearColor(0.0, .5, .5, 1.0);
	// Enable (per-fragment) depth testing.
	glEnable(GL_DEPTH_TEST);
	
	// Create the shader program from the predefined source filenames.
	shaderProgram = initShaderProgram(VERT_SRC, FRAG_SRC);
	if(!shaderProgram) {
	    printf("failed creating shaders");
    	return 1;
    }
	return 0;
	
}

/**
	Renders the scene.
	
	Parameters:
		None
	
	Returns:
		None
*/
void render(void)
{   
    static float rot = 0;
    float projection[16];
    float modelview[16];
    float translate[] = {0.0f, 0.0f, -5.0f}; //vector to translate by
    mat4_perspective(90.0, 640.0/480.0, 0.1, 1000.0, projection);//set the projection matrix to a perspective transform
    mat4_identity(modelview);//set the modelview matrix to identity
    mat4_translate(modelview, translate, NULL); //[MDV] = [I] * [TRANSLATE]
    mat4_rotateY(modelview, rot, NULL); //[MDV] = [I] * [TRANSLATE] * [ROTATION]
    rot += 0.01;
	// Start using our shader program.
	glUseProgram(shaderProgram);

    //get the attribute locations
    int posAttrib = glGetAttribLocation(shaderProgram, "posAttrib");
    int colorAttrib = glGetAttribLocation(shaderProgram, "colorAttrib");
	
	// Enable the use of the program's attribute slots.
	glEnableVertexAttribArray(posAttrib);
	glEnableVertexAttribArray(colorAttrib);
	
	// Send all our geometry data to the graphics card, aligning it with
	// the appropriate attributes.
	glVertexAttribPointer(posAttrib, 3, GL_FLOAT, GL_FALSE, 0, positions);
	glVertexAttribPointer(colorAttrib, 3, GL_FLOAT, GL_FALSE, 0, colors);
	
    //get the uniform locations
    int projloc = glGetUniformLocation(shaderProgram, "projection");
    int modvloc = glGetUniformLocation(shaderProgram, "modelview");
    
    //set the matrix uniform data
    glUniformMatrix4fv(projloc, 1, GL_FALSE, projection);
    glUniformMatrix4fv(modvloc, 1, GL_FALSE, modelview);
	
    // Draw a bunch of triangles, whose vertices make them a box.
	glDrawArrays(GL_TRIANGLES, 0, 36);
	
	// Re-disable the attributes for state-persistence.
	// We wouldn't want any other potential function to have to
	// worry about what this function changes in the OpenGL state.
	glDisableVertexAttribArray(posAttrib);
	glDisableVertexAttribArray(colorAttrib);
	// For the same reasons we stop using the shader program.
	glUseProgram(0);

    //deal with any errors
    int err = glGetError();
    if(err != GL_NO_ERROR) {
        printf("ERROR: %d\n:",err);
    }
}

/**
	The main function of this example.
*/
int main(void)
{
	// Try to initialize our stuff.
	if(init()) return 1;
	printf("init ok\n"); fflush(NULL);
	// "While the X button of our window is not clicked"
    while (!glfwWindowShouldClose(window))
    {
		// Clear the depth and color buffers. 
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		// Render the scene.
		render();
		// Swap front-back buffers.
        glfwSwapBuffers(window);
		// Check to see if anything has changed about our
		// current rendering context, and update GLFW accordingly.
		// This includes clicking the X button.
        glfwPollEvents();
    }
	
	// After the window is closed, we clear out our GLFW holdings,
    glfwTerminate();
	// and exit.
	return 0;
}
